# Chapter12. 회복 탄력성

- 신뢰할 수 있는 소프트웨어
- 마이크로서비스를 사용하는 이유. 무엇보다 서비스 제공을 위한 `회복 탄력성`을 향상시킬 것이라고 기대하기 때문.
    - 소프트웨어의 회복 탄력성을 개선하는 과정에서 마이크로서비스 아키텍처를 채택하는 것은 단지 퍼즐의 일부일 뿐이라는 사실이 밝혀짐.

## 1. 회복 탄력성이란?

### 1-1. 견고성 robustness

- 우리는 직면할지도 모르는 변동의 종류를 잘 이해하고 이러한 문제가 발생할 때 시스템이 잘 처리할 수 있도록 조치를 취한다.
    - 호스트 고장 => 교체 호스트 자동으로 가동
    - 네트워크 연결 시간 초과 => 재시도 수행
    - 마이크로서비스가 가용 상태가 아닌 상황 => 해당 서비스의 오류를 적절한 방식으로 처리
- 위와 같은 조치를 통해 아키텍처의 견고성을 개선할 수 있다.
- 견고성은 소프트웨어에만 해당되는 것은 아니며 사람들에게 적용될 수 있다.
    - 소프트웨어 담당자가 한 명인데 사고? => 대기 중인 백업 담당자.
- 견고성을 향상시키려는 모든 시도는 단순한 비용/이점 분석 측면뿐만 아니라 이 결과로 갖게 될 더 복잡한 시스템에 만족할지 여부도 고려해야 한다.
    - ex. 아키텍처를 k8s로 이동

### 1-2. 회복성 rebound

- 중단으로부터 얼마나 잘 복구되는가.
- 사전에 준비하면 장애로부터 회복하는 능력이 향상된다.
    - 백업을 준비 => 데이터 손실을 더 잘 복구할 수 있다.
- 플레이북
    - 장애가 발생했을 때 각자에게 주어진 역할.

### 1-3. 원만한 확장성 graceful extensibility

- 전혀 예측하지 못한 문제가 터진다면?
    - 수평 조직이 더 잘 대처할 수 있다.
    - 만약 엄격한 규칙을 지켜야 한다면 대처하는 능력이 크게 약화될 것이다.
- 시스템 최적화는 양날의 검.
    - 자동화. 많은 인력을 대체할 수 있지만 돌발 상황은 처리할 수 없다.

### 1-4. 지속적인 적응력 sustained adaptability

- 지속적인 적응력을 갖추려면 안주하지 않아야 한다.

> "우리가 이전에 얼마나 잘해왔든, 얼마나 성공했든 미래는 다를 수 있고, 우리가 잘 적응하지 못할 수도 있습니다.
> 우리는 그 새로운 미래 앞에 위태롭고 연약할 수 있습니다."
> - 데이비드 우즈

- 시스템에 대한 전체적인 관점으로 접근해야 한다.
    - 팀이 조직 수준에서 지속적인 적응력을 확보하기 위해선 자율성이 필요하다.
- 징계에 대한 두려움 없이 자유롭게 정보를 공유하는 환경의 구축을 중시하는 문화를 만드는 것은 장애로부터 학습을 장려하는 데 필수적이다.

### 1-5. 그리고 마이크로서비스 아키텍처

- 넓게 보면, 회복 탄력성을 제공하는 능력은 소프트웨어 그 자체가 아니라 시스템을 구축하고 운영하는 사람들의 속성이다.

<br/>

## 2. 장애는 어디에서나 발생한다.

- 실패할 가능성이 있는 상황을 이해하는 것이 시스템의 견고성을 개선하는 핵심이다.

## 3. 얼마나 많아야 너무 많은 건가?

- 얼마나 많은 실패를 허용할 수 있는지 또는 시스템이 얼마나 빨라야 하는지는 시스템의 사용자에 의해 결정된다.
- 부하와 실패를 더 잘 처리하기 위해 시스템을 확장할지 여부와 그 방법을 고려할 때는 다음 요구 사항을 이해하는 것에서 시작하라.

#### 응답 시간/지연 시간

- 다양한 사용자 수로 측정
- 네트워크의 특성상 항상 이상값이 있으므로, 모니터링되는 응답의 특정 백분위수에 대한 목표를 설정하면 도움이 된다.
    - ex) 초당 200개의 동시 접속을 처리할 때 웹 사이트 응답 시간의 90%가 2초 미만을 유지할 것으로 예상된다.

#### 가용성

- 서비스가 다운타임 기간을 측정하는 것은 보고 기록 관점에서 실제로 유용한다.

#### 데이터 내구성

- 데이터 손실은 어디까지 허용되는가?
- 데이터를 얼마나 오래 보관해야 하는가?


## 4. 기능 저하

- 우리가 해야 할 일은 각 장애의 영향도를 파악하고 기능을 적절하게 저하시키는 방법을 찾는 것이다.
- 비즈니스 맥락을 이해하지 못하면 어떤 조치를 취해야 하는지 이해할 수 없다.
- 교차 기능 요구 사항의 측면에서 각 기능들의 중요성을 판단하면 우리가 무엇을 할 수 있는지 훨씬 더 잘 정할 수 있다.

## 5. 안정성 패턴

- 심각한 파급 효과를 피하기 위해 사용하는 몇 가지 패턴
- 호출을 모두 가로채 필요한 경우 이전 시스템으로 되돌림 => `교살자 무화과 패턴 Strangler Fig Pattern` 사용

- 매우 느리게 응답하는 것은 우리가 경험할 수 있는 최악의 실패 모드 중 하나.
    - 전체 시스템 속도가 느려지고 리소스 경합을 발생시킬 수 있으며 연쇄적인 장애를 초래할 수 있다.
    - 실패의 원인이 무엇이든 시스템 전체의 장애를 유발하는 다운스트림 하나가 시스템을 중단시킬 수 있다.
- `느리게 작동하는 시스템`은 `빠르게 실패하는 시스템`보다 다루기 훨씬 어렵다.
    - 그만큼 분산 시스템에서 지연 시간은 치명적이다.
    - 필자는 문제를 해결하기 위해 `타임아웃`을 올바르게 설정하고, 서로 다른 커넥션 풀을 구현하기 위해 `벌크헤드`를 구현하고, 애초에 비정상 시스템에 호출을 보내지 않도록 `회로 차단기`를 구현.

### 5-1. 타임아웃

- 간과하기 쉽지만 분산 시스템에서 올바르게 이해하는 것이 중요.
- 다운스트림 서비스에 대한 호출을 포기하기 전에 얼마나 기다려야 하는가?
    - 너무 오래 기다려도 문제. 너무 빨리 초과해도 문제다.

> #### TIP
> - 타임아웃은 매우 유용하다.
> - 다른 프로세스를 호출하는 데 항상 타임아웃을 설정하고 모든 곳에 기본 타임아웃 값을 지정하라.
> - 타임아웃이 발생하면 기록하고, 어떤 일이 발생하는지 살펴보고, 그 결과에 따라 변경하라.
> - 다운스트림 서비스에 대한 '정상' 상태의 응답 시간을 확인하고 이를 이용해 타임아웃 임계값을 설정하라.

> #### CAUTION
> - 단일 서비스 호출에 대한 타임아웃만 고려하면 안 된다.
> - 즉, 해당 작업 전체에 대한 타임아웃을 생각하고 전체 타임아웃 예산이 초과하면 연산 전체를 중단하라.

### 5-2. 재시도

- 일부 다운스트림 호출의 문제는 일시적이다.
    - 이런 경우는 재시도하는 것이 많은 도움이 된다.
- 재시도해야 할 다운스트림 호출 실패의 종류를 고려하면 유용하다.
    - `404 Not Found`에서는 유용하지 않다. (어차피 또 실패하기 때문)
    - `503 Service Unavailable`이나 `504 Gateway Time-out`이 발생한다면 일시적인 오류로 간주해 재시도하는 것이 적절하다.
- 재시도하기 전에 지연 시간이 필요할 수 있다.
    - 다운스트림에 부하가 걸렸을 수 있는데, 추가 요청을 쏟아내는 것은 좋지 않은 생각일 수 있다.
    - 만약 사용자와 직접 대면하지 않는 작업의 일부분에서 발생했다면, 작업 완료를 위해 더 오래 기다려도 괜찮을 것이다.

### 5-3. 벌크 헤드

- `격벽 bulkhead`
- 선박에서 선체의 다른 부분을 보호하기 위해 밀봉할 수 있는 선첵의 일부분을 뜻한다. 배에 물이 들어오면 격벽 문을 닫는 식이다.
- 소프트웨어 아키텍처 관점에서는 매우 다양한 격벽이 있다.
    - 커넥션 풀 사용
    - 관심사의 분리. 기능을 별도의 마이크로서비스로 분리하여 장애의 전파를 차단.
- 지금까지의 패턴 중 가장 중요.
    - 타임아웃과 회로 차단기는 자원이 제한될 때 자원을 확보하는 데 도움이 되지만, 격벽은 처음부터 자원이 제한되는 것을 방지할 수 있다.
- 자원이 포화되지 않도록 특정 조건에서 요청을 거부할 수 있는 기능을 제공할 수 있는데, 이를 `로드 셰딩 load shedding`이라고 한다.
    - 때로는 요청을 거부하는 것이 중요한 시스템을 무너뜨리지 않고 여러 업스트림 서비스에 병목 현상이 발생하지 않도록 하는 가장 좋은 방법이다.

### 5-4. 회로 차단기

- 회로 차단기는 다운스트림 문제로부터 소비자를 보호할 뿐만 아니라 잠재적으로 부정적인 영향을 미칠 더 많은 호출로부터 다운스트림을 보호하기 위해 격벽을 봉쇄하는 자동 메커니즘으로 생각할 수 있다.
- 연쇄적 실패를 감안해 모든 동기식 다운스트림 호출에 대한 회로 차단기를 의무화하는 것이 좋다.
- 회로 차단기가 끊어진 동안 몇 가지 옵션이 있다.
    1. 요청을 큐에 넣고 나중에 재시도 (특히 비동기 작업의 일부로 수행될 때 적합)
    2. 동기 호출 체인이라면, 빨리 실패하는 것이 낫다.
- 빠르게 실패하는 것은 느리게 실패하는 것보다 항상 더 낫다.

### 5-5. 격리

- 마이크로서비스가 다른 마이크로서비스의 가용성에 더 많이 의존할수록 한 마이크로서비스의 상태가 다른 마이크로서비스의 작업 수행 능력에 더 많은 영향을 미친다.
- 서비스 간의 격리를 강화하면 다운스트림 서비스의 중단으로 인해 영향을 받을 가능성이 줄어든다.
    - 또한 서비스 소유자 간의 조정 작업이 훨씬 줄어들게 된다.

### 5-6. 이중화

- 무언가를 보유하는 것은 구성 요소의 견고성을 향상시키는 좋은 방법이 될 수 있다.

### 5-7. 미들웨어

- 메시지 브로커와 같은 미들웨어를 사용해 일부 견고성 문제를 해소하는 것이 유용할 수 있지만 모든 상황에 적용되지는 않는다.

### 5-8 멱등성

- `멱등적 idempotent` 연산은 첫 번째 적용 이후 연산을 여러 번 적용하더라도 결과가 변경되지 않는 연산을 뜻한다.ㄴ
- 연산에 멱등성이 있다면 부정적인 영향 없이 호출을 여러 번 반복할 수 있다.

<br/>

## 6. 위험 분산

- 회복 탄력성을 위해 확장하는 한 가지 방법은 모든 달걀을 한 바구니에 담지 않는 것이다.
    - 호스트를 여러 개의 다른 물리 머신으로 분산.
    - 두 곳 이상의 데이터 센터에 분산되도록 하는 것. (예를 들어, AWS는 리전으로 분리되어 있음)

## 7. CAP 정리

- 다양한 종류의 데이터 저장소가 가진 장점을 논하는 토론에서 CAP 정리.
- 이 정리의 핵심은 분산 시스템에서는 아래 세 가지 조건을 서로 절충할 수 있다는 점이다.
    - `일관성 Consistency`: 여러 노드로 이동해도 동일한 답을 얻을 수 있는 시스템 특성
    - `가용성 Availability`: 모든 요청이 응답을 받는다.
    - `단절내성 partition tolerance`: 부분 간 통신이 가끔 불가능하다는 사실을 처리하는 능력.

### 7-1. 일관성 희생

- AP 시스템
- 단절내성과 가용성을 유지하기 위해 일관성을 기꺼이 양보하는 시스템은 `최종 일관성`이 있다고 한다.

### 7-2. 가용성 희생

- CP 시스템
- 단절된 경우 데이터베이스 노드가 서로 통신할 수 없다면 일관성을 보장하기 위해 서로 조율할 수 없다.
- 일관성을 보장할 수 없으므로 유일한 선택은 요청에 대한 응답을 거부하는 것이다. 즉, 가용성을 희생하는 것이다.

### 7-3. 단절내성 희생

- 이런 경우는 없다. (CA 시스템은 없다.)
- 시스템에 단절내성이 없다면 시스템은 네트워크를 통해 실행할 수 없다.

<br/>

## 8. 카오스 엔지니어링

- 넷플릭스 내부 관행에서 이름을 따온 것.
- 시스템을 생각만큼 견고하게 유지하거나 시스템의 지속적인 적응성을 위한 접근 방법이라는 측면에서 복원력을 개선하는 데 유용한 접근법.

> 카오스 엔지니어링은 실환경에서 격동적인 조건을 견뎌내는 시스템의 능력에 대한 신뢰를 구축하기 위해 시스템을 실험하는 분야다.
> - 카오스 엔지니어링의 원칙

### 8-1. 게임 데이

- 특정 이벤트에 대한 사람들의 준비 상태를 테스트하기 위해 `게임 데이` 연습을 진행
- 가상의 상황을 가정해 사람과 프로세스를 테스트하는 기회를 제공

### 8-2. 운영 환경의 실험

- 넷플릭스의 운영 규모는 잘 알려져 있으며, 넷플릭스가 전적으로 AWS 인프라스트럭처에 기반을 두고 있다는 사실 또한 유명하다.
- 넷플릭스는 장애에 대한 계획을 세우는 것과 실제로 장애가 발생했을 때 소프트웨어가 장애를 처리할 수 있는지 아는 것은 별개의 문제라는 사실을 깨달았다.
    - 시스템에서 도구를 실행해 시스템이 장애를 견딜 수 있도록 해당 장애를 유도한다.
- 시스템이 실제로 견고한지를 테스트하는 궁극의 방법은 운영 환경 인프라에 유인원 군단을 풀어놓은 것이다.

### 8-3. 견고성을 넘어

- 넷플릭스는 운영 환경에서 특정 가상 머신의 가용성에 의존할 수 없다는 사실을 알았기 때문에 예상되는 문제를 시스템이 견딜 수 있도록 카오스 몽키를 구축했다.
- 단지 카오스 엔지니어링 도구를 실행한다고 해서 회복 탄력성이 생기지는 않는다는 점을 기억하라.

<br/>

## 9. 비난

- '근본 원인 분석 root cause analysis, RCA'의 개념은 문제의 근본 원인이 존재한다는 것을 의미하며, 그 근본 원인이 사람이길 바라는 경우는 놀라울 정도로 많다.
- 만약 한 사람의 실수로 한 회사 전체를 무너뜨릴 수 있다면? 그것은 개인보다는 회사에 대해 더 많은 것을 시사한다고 생각할 수 있다.
- 단기적인 책임 전가로 시작한 것이 일이 잘못됐을 때 앞으로 나서서 말하지 않게 되는 두려움의 문화까지 생기고 만다.
- 궁극적으로 회복 탄력성을 확보하려면 호기심, 즉 시스템의 약점을 끊임없이 탐구하려는 노력이 필요하다.
    - 배움의 문화. 사고를 겪은 후에 큰 깨달음을 얻을 수도 있다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
