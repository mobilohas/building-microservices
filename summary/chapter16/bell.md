# Chapter16. 진화하는 아키텍트

- 팀마다 다른 프로그래밍 관용구를 사용하도록 허용해야 하는지, 마이크로서비스를 분할하거나 병합해야 하는지 등에 대한 결정은 어떻게 내려야 할까?
- 변화의 속도가 빨라짐 => 아키텍트의 역할도 변화해야 한다.

## 1. 이름에 내포된 것은?

> 계속 그 단어를 쓰네요. 하지만 당신이 생각하는 그런 의미는 아닌 것 같아요.
> - 검술가 이니고 몬토야 "프린세스 브라이드"

- 아키텍트의 중요한 업무
    - 고객이 필요로 하는 소프트웨어를 제공하는 데 도움이 되는 기술적 비전을 시스템에 통합하는 일.
    - 어떤 곳에서는 단지 한 팀과 협력해야 할 수도 있는데, 이 경우 아키텍트의 역할과 기술 책임자의 역할이 동일한 경우가 많다.
    - 다른 곳에서는 전체 작업 프로그램의 비전을 정의하고 전 세계의 여러 팀이나 조직 전체와 협력해야 할 수도 있다.
- 어떤 수준의 아키텍트로 일하든 아키텍트의 역할은 명확히 규정하기 어렵다.
    - 다른 어떤 역할보다 비판을 많이 받는 역할이기도 하다.
    - 구축된 시스템의 품질, 동료의 근무 환경, 조직의 변화 대응 능력에 직접적인 영향을 미칠 수 있지만, 그 역할에 대한 이해도가 매우 낮은 것 같다.
    - 그 이유는?
- 건축 분야와 다르게 IT 자격증이 쓸모 없는 이유? => 무엇이 '좋은지' 판단하는 것과 관련해 우리가 아는 것이 없기 때문.
    - 소프트웨어 산업의 역사가 길지 않아 업계가 동의할 수 있는 절대적인 기준이 훨씬 적다는 문제도 존재한다.
- 건축 분야 아키텍트?
    - 변경에 따른 비용이 굉장히 높다.
    - 반면 소프트웨어는 언제든 변경할 수 있다.

## 2. 소프트웨어 아키텍트란?

- 소프트웨어 아키텍처에 대한 가장 유명한 정의 중 하나는 랄프 존슨에게서 나왔다.
- "아키텍처는 중요한 것에 관한 것이다. 그것이 무엇이든 간에."

> - 대부분의 성공적인 소프트웨어 프로젝트에서 해당 프로젝트에 참여하는 전문 개발자들은 시스템 설계에 대한 공유된 이해를 갖고 있다.
> - 이 공유된 이해를 '아키텍처'라고 한다.
> - 이와 같은 이해에는 시스템이 구성 요소롤 분해되는 방식과 구성 요소가 인터페이스를 통해 상호작용하는 방식이 포함된다.
> - 이러한 구성 요소는 일반적으로 더 작은 구성 요소로 구성되지만, 아키텍처에는 모든 개발자가 이해하는 구성 요소와 인터페이스만 포함된다.

- 여기서 `구성 요소 component`라는 용어를 가장 일반적인 의미로 사용하고 있다.
    - 이 책의 맥락에서 생각 => 컴포넌트는 마이크로서비스를 의미
- 아키텍처 = 시스템의 형태
    - 의도적이든 우발적이든 생겨난다.
    - 살아가는 사람들에게는 보이지 않을 수 있다. 실제로 존재하지 않을 정도로 아주 미미할 수도 있다.
    - 올바른 결과를 산출할 수도. 숨막히고 위압적인 것일 수도 있다.
- "따라서 아키텍처를 `사람들이 바꾸기 어렵다고 인식하는 것`으로 정의하게 될지 모른다."
- 바꾸기 어려운 것일수록 우리가 올바른 방향으로 나아가고 있는지 확인하기 위해 미리 생각해야 한다.
- 많은 소프트웨어 아키텍처는 변경하기 어려운 요소에 대해 생각하는 것이지만, 설계에서 변경할 수 있는 공간을 만드는 것이기 하다.

## 3. 변화를 가능하게

- 설계가 진화하는 과정을 통해 개발. 시그램 빌딩.
- 마이크로서비스 아키텍처의 공간에서 변화를 허용하는 방법?

## 4. 아키텍처에 대한 진화하는 비전

- 소프트웨어 아키텍트는 완벽한 최종 결과물을 만드는 것에서 벗어나 올바른 시스템이 등장하고 우리가 더 많은 것을 배우면서 계속 성장할 수 있는 `프레임워크`를 만드는 데 집중해야 한다.
- 에릭 도에넨버그는 아키텍트의 역할을 건축 환경의 건축가보다는 도시 설계자로 봐야 한다고 생각.
    - 특정 제약 조건 내에서 지역적 의사결정을 내릴 수 있는 구역을 정의.
    - 도시 설계자는 한 구역에서 일어나는 일에 대해 너무 많이 걱정하기보다는 사람과 공공시설이 한 구역에서 다른 구역으로 어떻게 이동하는지 파악하는 데 훨씬 더 많은 시간을 할애할 것.

## 5. 시스템 경계 정의

- 아키텍트로서 구역 내부에서 일어나는 일보다는 구역 간에 일어나는 일에 대해 더 많이 고민해야 한다.
- 즉, 마이크로서비스가 서로 통신하는 방식에 대해 생각하고 시스템의 전반적인 상태를 제대로 모니터링할 수 있는지 확인하는 데 시간을 할애해야 한다.
    - 구체적인 경계를 정의함으로써 아키텍처의 근본적인 측면을 손상시키지 않고 더 자유롭게 변경할 수 있는 시스템을 구축하는 동료들에게 강조한다.
    - 이것이 아키텍처 분야에서 우리만의 `보편적 공간`을 정의하는 방법이다.
- 시스템 전체를 손상시키지 않고 이러한 변경을 수행할 수 있는 공간을 정의함으로써 개발자의 삶을 더 수월하게 만들고 변경하기 어려운 시스템 부분에 주의를 집중할 수 있다.
- 정보 은닉의 개념
    - 마이크로서비스 경계 안에 정보를 숨기면 소비자를 위한 안정적인 인터페이스를 훨씬 쉽게 만들 수 있다.
    - 또한 변경할 때, 외부 소비자와의 호환성을 깨뜨리지 않았는지 확인하기가 더 쉽다.
- 성공적인 아키텍처는 무엇보다도 사용자의 요구에 맞게 변경할 수 있도록 하는 것이다.
    - 하지만 사람들은 시스템이 사용자만 수용하는 것이 아니라 실제로 소프트웨어를 구축하는 사람들도 수용한다는 사실을 자주 잊어버리곤 한다.
    - 성공적인 아키텍처는 업무를 수행하기 좋은 환경을 조성하는 데도 도움을 준다.

## 6. 사회적 구조물

- 건축 환경의 건축가는 건물을 구성하는 사람들과 협력해 비전이 무엇인지 이해하도록 도울 뿐만 아니라 비전과 현실의 괴리감이 클 때는 계획을 변경해야 한다.

> 초기에 소프트웨어 집약적 시스템의 아키텍처는 비전의 성명서와 같다. 결국 모든 시스템의 아키텍처는 그 과정에서 이뤄진 수십억 개의 크고 작은, 의도적이거나 우발적인 설계 결정의 산물이다.
> - 그래디 부치

- 즉, 아키텍처를 궁극적으로 책임지는 전담자가 있더라도 이 비전을 실행에 옮기는 데는 많은 사람이 참여해야 한다.
    - 성공적인 아키텍처를 구현하려면 팀의 노력이 필요하다.

## 7. 거주 가능성

- 건축 환경에서 유래돼 소프트웨어 개발 분야에서 공감을 불러일으키는 또 다른 개념은 `거주 가능성 habitability`이다.

> 거주 가능성이란 나중에 코드를 재사용하는 프로그래머가 코드의 구조와 의도를 이해한 후 편안하고 자신 있게 변경하도록 해주는 소스 코드의 특성을 말한다.
> - 리처드 가브리엘

- 하지만 현대의 소프트웨어 개발 생태계는 코드뿐만 아니라 우리가 사용하는 기술과 채택하는 작업 관행까지도 확장된다.
- 아키텍처를 발전시키고 사용하는 도구와 기술을 선택하는 과정을 협업하는 프로세스로 만들수록 시스템을 구축하는 사람들이 행복하고 생산적으로 일할 수 있는 환경을 조성하는 것이 쉬워진다.
- 우리가 만드는 시스템을 개발자들이 사용할 수 있도록 하려면 설계자와 기타 의사결정권자가 자신의 결정이 어떤 영향을 미치는지 이해해야 한다.
    - 팀과 함께 시간을 보내고, 팀과 함께 코딩.
    - 페어 프로그래밍.

## 8. 원칙적 접근법

> 규칙은 어리석은 자의 순종과 지혜로운 자의 인도를 위한 것이다.
> - 더글러스 베이더

- 시스템 설계에서 의사결정을 내리는 것은 결국 `절충점 trade-off`에 관한 것이며, 마이크로서비스 아키텍처는 우리에게 많은 절충안을 제공한다.
- `틀 만들기 framing`은 달성하려는 목표에 따라 의사결정을 인도하는 일련의 원칙과 관행을 정의하는 것이다.
    - 의사결정의 틀을 잡는 가장 좋은 방법이다.

### 8-1. 전략적 목표

- 아키텍트의 역할은 이미 충분히 어렵기 때문에 다행히도 전략적 목표까지 정의할 필요는 없다.
- 전략적 목표는 회사가 나아가고자 하는 방향과 고객을 가장 잘 만족시킬 수 있는 방법을 제시해야 한다.
    - 이와 같은 목표는 최고 수준의 목표이므로 기술이 전혀 포함되지 않을 수 있다.
- 수준별 목표 설정 가능
    - 회사 수준 / 부서 수준

### 8-2. 원칙

- 현재 하고 있는 일을 더 큰 목표에 맞추기 위해 만든 규칙. 때때로 변경될 수 있다.
- 예시: 조직의 전략적 목표
    - 새로운 기능의 출시 기간을 단축 => 제공 팀들은 다른 팀과 독립적으로 소프트웨어의 수명주기 동안 모든 권한을 갖고 준비가 되면 언제든 출시하도록 원칙을 정의할 수 있다.
    - 다른 국가에 공격적으로 서비스 확장 => 데이터 주권을 존중하기 위해 전체 시스템을 해당 국가 지역에 배포할 수 있도록 이식성이 있어야 한다는 원칙을 구현하기로 정할 수 있다.
- 너무 많은 원칙 X. 10개 미만이 적당.
- Heroku의 12가지 원칙.

### 8-3. 관행

- 관행은 원칙이 제대로 이행되고 있는지 확인하는 방법.
    - 업무 수행을 위한 세부적이고 실용적인 지침.
    - 관행은 기술에 따라 다름.
    - 모든 개발자가 이해할 수 있을 정도로 자세한 수준이어야 한다.
    - 코딩 지침. 모든 로그 데이터를 중앙에서 캡처. HTTP/REST가 표준 통합 방식이라는 사실 등.
- 관행은 원칙을 뒷받침한다.

### 8-4. 원칙과 관행의 결합

- 한 사람의 원칙이 다른 사람의 관행이 될 수 있다.
    - ex. HTTP/REST 사용.

## 9. 진화하는 아키텍처 가이드

- 아키텍처가 고정된 것이 아니라 끊임없이 변화하고 진화하는 것이라면, 어떻게 해아 우리가 관리할 수 없는 고통과 괴로움, 비난의 덩어리로 변이를 일으키지 않고 아키텍처를 원하는 방식으로 성장시키고 변화시킬 수 있을까?
    - 아키텍처의 상대적 '적합성'

> 소프트웨어에서 적합성 함수는 개발자가 중요한 건축적 특성을 유지하고 있는지 확인한다.

- 적합성 함수의 개념은 중요한 속성들의 현재 상태를 이해하는 데 사용되며, 해당 속성이 허용 범위를 벗어나 변경되는 경우 변경 사항을 조사해야 한다는 것이다.
    - 일반적으로 아키텍처가 정해진 원칙과 제약 조건에 따라 구축되고 있는지 확인하는 데 사용된다.
- 실제 데이터를 수집해 아키텍처가 해당 기준에 따라 '적합성' 달성 여부를 파악하는 것이다.
    - 시스템 성능, 코드 결합, 주기 시간 또는 기타 여러 측면과 관련될 수 있다.

## 10. 스트림 정렬 조직의 아키텍처

- 15장의 `스트림 정렬 모델 stream-aligned model`, 그리고 스트림 정렬 팀을 교차 지원하는 `활성화 팀 enabling team`
- 이 세계에서 아키텍트는 어디에 속하는가?
    - 스트림 정렬 팀의 범위는 전담 아키텍트가 필요할 정도로 복잡할 때도 있다.
    - 대부분의 경우 아키텍트는 여러 팀에서 업무를 수행해야 한다.
- 많은 책임을 활성화 책임으로 볼 수 있다.
    - 기술 비전의 명확한 전달
    - 새로운 과제 파악
    - 사람들을 연결하고, 더 큰 그림을 주시하며, 팀이 하고 있는 일이 더 큰 전체에 어떻게 부합되는지 이해하도록 도와준다.
- 선호하는 모델 => 소수의 전담 아키텍트를 두되, 시간이 지남에 따라 각 제공 팀의 기술 전문가로 팀을 보강하는 것.
    - 아키텍트는 해당 그룹이 제대로 작동하는지 확인할 책임이 있다.
- 그룹이 아키텍트가 동의하지 않는 결정을 내린다면?
    - 가장 어려운 상황 중 하나.
    - 최대한 설득. 하지만 결정에 따름.
    - 집단은 개인보다 훨씬 현명.

## 11. 팀 구축

- 시스템의 기술 비전을 위한 주요 담당자가 되고 이 비전을 실행하는 과정에서 핵심적인 역할을 하는 것은 단순히 올바른 기술 결정을 내리는 데 그치지 않는다.
    - 함께 일하는 사람들이 그 작업을 수행해야 한다.
    - 기술 리더는 사람들이 성장하도록 지원하고, 비전을 만드는 데 동참하도록 도움을 주며, 비전을 형성하고 구현하는 데도 적극적으로 참여할 수 있도록 역할을 해야 한다.

## 12. 필수 기준

- 관행을 검토하고 절충점을 고려할 때 가장 중요한 균형 중 하나는 시스템에서 얼마나 많은 `가변성`을 허용할 것인지와 관련
- '잘 작동하는 마이크로서비스의 모습을 정의'

### 12-1. 모니터링

- 시스템 상태에 대한 일관된 `서비스 교차 뷰 cross-service view`를 만들 수 있어야 한다.
- 서비스별 뷰가 아니라 시스템 전체에 대한 뷰여야 한다.
    - 더 광범위한 문제를 진단하거나 더 큰 추세를 이행하려고 할 때 특히 유용.
- 이를 최대한 쉽게 작업하려면, 모든 마이크로서비스가 상태 관련 메트릭과 일반 모니터링 관련 메트릭을 동일한 방식으로 발송하는 것이 좋다.
- 각 마이크로서비스가 이 데이터를 중앙 위치로 푸시하는 푸시 메커니즘을 채택할 수 있다.
    - 어떤 방식을 사용하든 표준화된 방식을 유지하라.
    - 상자 안의 기술을 불투명하게 만들고, 이를 지원하기 위해 모니터링 시스템을 변경할 필요가 없게 하라.
    - 로깅도 같은 범주에 속하며, 한 곳에서 관리해야 한다.

### 12-2. 인터페이스

- 소수의 정의된 인터페이스 기술을 선택하면 새로운 소비자를 통합하는 데 도움이 된다.
- 단순히 기술과 프로토콜을 선태하는 문제가 아니다.
- ex. HTTP/REST
    - `동사 verb`를 사용할 것인가? `명사 noum`를 사용할 것인가?
    - 자원의 `페이지 매김 pagination`은 어떻게 처리할 것인가?
    - 엔드포인트의 버전 관리는 어떻게 처리할 것인가?

### 12-3. 아키텍처 안전

- 마이크로서비스가 다운스트림 호출의 장애로부터 스스로를 보호할 수 있도록 해야 한다.
- 다운스트림 호출의 잠재적 장애를 처리하지 못하는 마이크로서비스가 많을수록 시스템은 더 취약해진다.

## 13. 거번너스와 포장된 길

- 아키텍트가 처리해야 할 일 중 하나는 `거버넌스 governance`다.

> 거버넌스는 이해관계자의 요구, 조건, 옵션을 평가하고, 우선순위 지정 및 의사결정을 통해 방향을 설정하고, 합의된 방향과 목표에 대한 성과, 규정 준수, 진행 상황을 모니터링해 기업 목표를 달성할 수 있도록 보장한다.

- 거버넌스란
    - 일을 어떻게 수행해야 한느지 합의하고
    - 사람들이 어떻게 수행해야 하는지 알 수 있게 하며,
    - 일이 그렇게 수행되도록 하는 것으로 간주할 수 있다.
- 기본적으로 거버넌스는 그룹 활동이어야 한다.

### 13-1. 예시

- 서면 문서는 훌륭하고 유용하다. 하지만 개발자는 실행하고 탐색할 수 있는 코드도 좋아한다.
- 권장하고 싶은 표준이나 모범 사례가 있다면 참고할 만한 예시를 제공할 수 있어 유용하다.
    - 실제 마이크로서비스에서 사용되고 있어야. 모든 원칙이 실제로 의미가 있는지 확인할 수 있다.

### 13-2. 맞춤형 마이크로서비스 템플릿

- ex. 스프링 부트
- 프레임워크를 도입해 설정을 회사용으로 표준화.

#### 주의사항

- 템플릿의 선태과 구성은 주로 플랫폼 팀의 몫이다.
- 팀에 강제적인 프레임워크를 강요함으로써 팀의 사기와 생산성이 저하되는 경우가 적지 않았다.
- 채택되려면 개발자의 사용 편의성이 가장 중요한 기준이 된다는 점을 이해해야 한다.
- 템플릿을 사용하는 개발자가 조직 내부의 오픈 소스 모델의 일부로 프레임워크에 대한 변경 사항을 추천하고 기여할 수 있도록 허용하라.

### 13-3. 대규모로 포장된 길

- 서로 다른 다수의 기술 스택을 수용하려면 각각에 맞는 마이크로서비스 템플릿이 필요하다.
- 하지만 이를 위해서는 팀에서 언어 선택을 섬세하게 제한하는 방식이 필요할 것이다.

## 14. 기술 부채

- 종종 기술 비전을 완벽하게 실현할 수 없는 상황이 찾아온다.
    - 긴급한 기능 구현을 위해 몇 가지를 희생 => 장기적으로 대가를 치루게 된다.
- 때때로 지름길을 택함으로써가 아닌 다른 원인으로 기술 부채가 발생하기도 한다.
    - 시스템에 대한 비전의 변화. 그런데 모든 시스템이 일치하지 않는다면?

## 15. 예외 처리

- 규칙에 예외가 되는 결정을 내릴 때도 있다.
- 이러한 경우에는 나중에 참고할 수 있도록 그러한 결정을 로그 어딘가에 캡처하는 것이 좋다.

<br/>


# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
