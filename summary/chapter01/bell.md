# Chapter 01 마이크로서비스란?

## 1. 마이크로서비스 살펴보기

- 마이크로서비스는 비즈니스 도메인에 따라 모델링된 독립적으로 릴리스 가능한 서비스로, 기능을 캡슐화하고 네트워크를 통해 다른 서비스들에 액세스하게 해준다.
    - `재고 inventory`, `주문 관리 order management`, `배송 shipping`을 각각 대표할 수 있지만 한데 모으면 전체 전자 상거래 시스템을 구성할 수 있다.
    - 서비스 지향 아키텍처의 한 종류. 서비스 경계를 정하는 방법과 독립적인 배포 가능성이 핵심이라는 점 때문에 의견이 다소 분분하다.
- 외부에서 보면, 하나의 마이크로서비스는 블랙박스로 취급된다.
    - 가장 적절한 프로토콜(HTTP, gRPC, Message Queue 등)을 사용해 1개 이상의 네트워크 엔드포인트를 통해 비즈니스 기능을 호스팅한다.
    - 서비스 프로그애밍에 대한 기술이나 데이터 저장 방식과 같은 상세한 내부 구현 정보는 외부 세계에서 완전히 은폐한다.
    - 마이크로서비스 아키텍처가 대부분의 상황에서 공유 데이터베이스의 사용을 지양하는 것을 의미한다.
- `정보 은닉`은 가능한 한 많은 정보를 구성 요소에 감추고 외부 인터페이스를 통해 최소한의 정보만 노출하는 것을 의미한다.
    - 마이크로서비스 경계 내부의 변경은 업스트림 소비자에게 영향을 미치지 않으므로 독립적인 기능 릴리스가 가능하다.
    - 내부 구현이 변경되도라도 명확하고 안정적인 서비스 경계가 변경되지 않는다면, 시스템의 결합은 느슨해지고 응집력은 강해진다.

> #### 스트림
> - `업스트림 upstream`: 인접 시스템에 데이터를 전송하는 시스템
> - `다운스트림 downstream`: 수신하는 시스템

> #### 서비스 지향 아키텍처와 마이크로서비스는 다른가?
> - `서비스 지향 아키텍처 service-oriented architecture, SOA`는 특정 기능들을 제공하기 위해 다수 서비스가 협업하는 설계 방식이다.
> - 여기서 서비스는 일반적으로 완전히 분리된 운영 시스템의 프로세스를 의미하며 이러한 서비스 간 통신은 프로세스 경계 내부의 메소드 호출이 아니라 네트워크 간 호출로 이뤄진다.
> - SOA는 대규모 모놀리식 애플리케이션에 대항하기 위한 방안으로 생겨났다. 이 방식은 소프트웨어의 재사용성을 향상시키는 게 목표인데, 예를 들면 2개 이상의 사용자 애플리케이션이 동일한 서비스를 사용할 수 있도록 해준다.
> - 필자는 팀이 서비스를 더 작게 만들도록 애써도 여전히 모든 것이 데이터베이스에 결합돼 있고 전부 함께 배포해야 하는 SOA의 사례를 많이 봤다. 서비스 지향인가? 그렇더라도 마이크로서비스는 아니다.
> - 마이크로서비스 방식은 SOA를 더 잘하고자 시스템과 아키텍처를 충분히 이해하려는 노력에 실제로 사용되면서 등장했다. 마이크로서비스는 SOA에 대한 특정한 접근 방식이다.

<br/>

## 2. 마이크로서비스의 핵심 개념

### 2-1. 독립적 배포성

- 다른 마이크로서비스를 배포하지 않고도 마이크로서비스를 변경하고 배포하고 사용자에게 릴리스할 수 있다는 개념이다.
    - 이러한 작업을 수행할 수 있다는 사실뿐 아니라 실제로 시스템에서 배포를 관리하는 방법이 더욱 중요하며, 기본 릴리스 방식으로 채택하는 원칙이다.
    - 이 개념은 단순하지만 실행하기에는 간단치 않다.
- 독립적 배포를 위해서 마이크로서비스는 `느슨하게 결합 loosely coupled`시켜야 한다.
    - 다른 서비스를 변경하지 않고도 한 서비스를 변경할 수 있어야 한다.
    - 서비스 간에 분명하고 잘 정의되며 안정적인 계약이 필요하다는 것을 의미한다.
- 독립적 배포성. 그 자체로 매우 가치가 높지만 독립적 배포에 도달하려면 그 자체로 이점이 있는 다른 요소들도 제대로 갖춰야 한다.
- 안정적인 인터페이스를 갖고 느슨하게 결합된 서비스를 요구하는 목소리가 커지면서 마이크로서비스 경계를 찾는 방법을 가장 먼저 생각하게 됐다.

### 2-2. 비즈니스 도메인 중심의 모델링

- 도메인 주도 설계와 같은 기술을 사용하면 소프트웨어가 동작하는 실제 도메인을 더 잘 표현하도록 코드를 구성할 수 있다.
    - 마이크로서비스 아키텍처에서는 동일한 개념을 사용해 서비스 경계를 정의한다.
    - 비즈니스 도메인을 중심으로 서비스를 모델링함으로써 새로운 기능을 좀 더 쉽게 출시하고 마이크로서비스를 다양한 방식으로 재결합해 사용자에게 새로운 기능을 제공할 수 있다.
- `3계층 아키텍처 three-tiered architecture`로 대표되는 계층형 아키텍처를 자주볼 수 있다.
    - 아키텍처의 각 계층은 관련된 기술적 기능을 기반으로 하는 각 서비스 경계를 포함해서 서로 다른 서비스 경계를 나타낸다.
    - 이 유형의 아키텍처에서 기능 변경은 대개 여러 계층에 걸쳐 나타나 프레젠테이션, 애플리케이션, 데이터 계층의 변경이 필요하다.
    - 서비스를 비즈니스 기능 단위로(수직으로) 처음부터 끝까지 한 조각으로 만들면, 비즈니스 기능을 최대한 효율적으로 변경하도록 아키텍처를 배치할 수 있다.
    - 마이크로서비스에서 기술적 기능의 높은 응집도보다는 비즈니스 기능의 높은 응집력을 우선시 해보자.

### 2-3. 자기 상태 소유

- 마이크로서비스가 공유 데이터베이스 사용을 피해야 한다는 생각은 많은 사람을 힘들게 한다.
- 한 마이크로 서비스가 다른 마이크로서비스가 소유한 데이터에 액세스하려면 두 번째로 마이크로서비스에 데이터를 요청해야 한다.
    - 이는 마이크로서비스에 어떤 데이터를 공유하고 감출지 결정하는 능력을 제공하므로 자유롭게 변경할 수 있는 기능과 거의 변경하지 않는 기능을 명확히 분리할 수 있게 해준다.
- 독립적 배포성을 실현하려면 마이크로서비스에 대한 하위 호환성이 없는 변경을 제한해야 한다.
    - 만약 업스트림 소비자와의 호환성을 깨뜨리면 소비자들에게도 변경을 강요할 것이다.
    - 마이크로서비스에 대한 내부 구현 상세와 외부 계약을 명확하게 구분하면 하위 호환성이 없는 변경을 줄이는 데 도움이 된다.
- 마이크로 서비스에서 내부 상태를 감추는 것은 객체 지향 프로그래밍의 캡슐화와 유사하다.

> - 정말 필요한 경우가 아니라면 데이터베이스를 공유하지 말라.
> - 그리고 공유를 회피하기 위해 할 수 있는 모든 것을 수행하라. 데이터베이스 공유는 독립적 배포성을 달성하는 데 가장 나쁜 것 중 하나다.

### 2-4. 크기

- 마이크로서비스는 얼마나 커야 할까?
- 제임스 루이스는 '마이크로서비스는 내 머리만큼 커야 한다'라고 말한 것으로 알려져 있다.
    - 제임스의 말에 숨겨진 진의는 마이크로서비스는 쉽게 이해할 수 있는 크기로 유지돼야 한다는 것이다.
    - 물론 사람마다 이해하는 능력이 같지 않다는 문제가 있다.
    - 따라서 어떤 크키가 적절한지는 스스로 판단해야 한다.
- 크리스 리차드슨은 '마이크로서비스의 목적은 가능한 작은 인터페이스를 갖는 것'이라는 표현에서 짐작해볼 수 있다.
- 크기에 대한 걱정은 접어두자. 처음 시작할 때는 두 가지 핵심 사항에 집중하는 것이 훨씬 더 중요하다.
1. 얼마나 많은 마이크로서비스를 처리할 수 있는가?
- 서비스가 많을수록 시스템의 복잡성이 증가하고, 이에 대처하려면 새로운 기술을 배워야 한다.
- 마이크로서비스로의 전환은 복잡성을 유발하는 근원이 되며 이로 인해 발생할 수 있는 모든 문제를 야기한다.
- 이런 이유로 필자는 마이크로서비스 아키텍처로 점진적으로 전환해야 한다고 강력히 주장한다.
2. 모든 것이 끔찍하게 결합돼 엉망인 상황을 피하면서 마이크로서비스 경계를 최대한 활용하려면 어떻게 경계를 정의해야 하는가?
- 이러한 주제는 마이크로서비스로 향하는 여정을 시작할 때 집중해야 하는 훨씬 중요한 것들이다.

### 2-5. 유연성

- '마이크로서비스는 선택권을 제공한다'는 말을 생각해보자.
    - 마이크로서비스는 비용이 들기 때문에 그 비용이 선택하려는 옵션의 가치에 견줘 적당한지 따져봐야 한다.
    - 그 결과로 얻는 유연성은 조직성, 기술성, 규모, 견고함 등 여러 측면에서 놀라울 정도로 매력적일 수 있다.
- 마이크로서비스의 채택은 '스위치를 켜는 것'이 아니라 '다이얼을 돌리는 것'과 같다고 생각해야 한다.
    - 다이얼을 높은 쪽으로 돌리고 더 많은 마이크로서비스를 사용할수록 유연성은 높아진다.
    - 하지만 그만큼 고충도 늘어난다. 이런 이유로 점진적인 마이크로서비스 채택을 강력히 지지한다.

### 2-6. 아키텍처와 조직의 정렬

- `콘웨이의 법칙 Conway's law`은 다음과 같이 명시한다.
    - '시스템을 설계하는 조직은 ... 이러한 조직의 커뮤니케이션 구조를 본떠 설계하도록 제한된다.'
- 3계층 아키텍처는 관련 기술의 응집력은 높지만 비즈니스 기능의 응집력이 낮은 아키텍처다.
    - 비즈니스 기능이 3계층에 모두 분산되어 있기 때문이다.
    - 변경을 더 쉽게 만들고 싶다면, 기술보다는 비즈니스 기능의 응집력을 선택해 코드를 그룹화하는 방법을 바꿔야 한다.
    - 각 서비스는 3계층의 조합을 포함하거나 포함하지 않을 수 있지만, 특정 서비스의 구현과 관련된 문제다.

<br/>

## 3. 모놀리스

- 마이크로서비스는 모놀리식 아키텍처의 대안인 아키텍처 접근 방식으로 가장 자주 거론된다.
- 따라서 마이크로서비스 아키텍처를 더 명확히 식별하고 마이크로서비스가 고려할 만한 가치가 있는지 더 잘 이해할 수 있도록 모놀리스의 정확한 의미도 함께 논의해야 한다.
- 시스템의 모든 기능이 함계 배포돼야 한다면 필자는 이를 모놀리스로 간주한다.

### 3-1. 단일 프로세스형 모놀리스

- 견고성과 확장성을 위해 이 프로세스의 인스턴스를 여러 개 만들 수 있지만, 근본적으로 모든 코드는 하나의 프로세스로 패키징된다.
- 실제로 이러한 단일 프로세스 시스템은 십중팔구 데이터베이스에서 데이터를 읽고 저장하거나 웹 및 모바일 애플리케이션에 정보를 제공하므로 그 자체로 단순한 분산 시스템일 수 있다.
- 그러나 조직이 성장하면서 모놀리스 역시 잠재적으로 함께 성장하게 되고, 그에 따라 모듈식 모놀리스로 시선이 옮겨진다.

### 3-2. 모듈식 모놀리스

- 단일 프로세스형 모놀리스의 서브셋인 `모듈식 모놀리스 modular monolith`는 단일 프로세스가 별도의 모듈로 구성된 변형이다.
- 각 모듈은 독립적으로 작업할 수 있지만 매포하려면 모두 다 합쳐야 한다.
- 많은 조직에서 모듈식 모놀리스는 훌륭한 선택이 된다.
    - 모듈 경계가 잘 정의된다면, 훨씬 더 간단한 배포 토폴로지를 활용함으로써 분산된 마이크로서비스 아키텍처의 문제를 피하면서도 높은 수준으로 병행 작업을 할 수 있다.
- 모듈식 모놀리스의 한 가지 문제점은 데이터베이스가 코드 수준으로 분해되지 않아서 미래에 불행하게도 사람들은 모놀리스 그 자체만으로 문제가 있는 것으로 여기게 돼, 피해야 하는 것이라고 생각한다.
- 모놀리스 아키텍처를 소프트웨어 전달에 대한 타당한 선택지에서 고의로 제외하는 함정에 빠진다면 우리 자신과 소프트웨어 사용자에게 올바른 일을 수행하지 못할 위험이 따른다.ㄴ

<br/>

## 4. 활성화 기술

- 마이크로서비스를 처음 사용할 때는 새로운 기술을 많이 채택할 필요가 없다. 오히려 역효과를 낳을 수 있기 때문이다.
    - 그 대신에 마이크로서비스 아키텍처를 확장하면서 점차 분산되는 시스템으로 인해 발생하는 문제를 지속적으로 찾고 도움이 될 만한 기술을 찾아야 한다.

### 4-1. 로그 집계와 분산 추적

> 마이크로서비스를 시작할 때 너무 많은 기술을 도입하는 것에 유의하라. 다만, 로그 집계 도구는 매우 중요하므로 마이크로서비스를 채택하기 전에 준비해야 한다.

- 로그 집계 시스템을 사용하면 모든 서비스에서 로그를 수집하거나 집계하고 한 곳에서 분석할 수 있으며, 능동적인 경보 메커니즘 일부도 만들 수 있다.
- 연관된 서비스 호출에 사용되는 단일 ID인 상관관계 ID를 구현해 이러한 로그 집계 도구를 훨씬 유용하게 만들 수 있다.
    - 예를 들면 호출 체인의 경우 사용자 상호작용으로 트리거될 경우가 많다.
    - 이 ID를 각 로그 항목에 기록하면 지정된 호출 플로와 관련된 로그를 훨씬 쉽게 분리할 수 있고, 문제 해결도 더 수월해진다.
- 시스템이 복잡해짐에 따라 시스템이 수행하는 작업을 더 잘 알아낼 도구들을 고려하는 것이 더 중요해진다.
    - 이 도구들은 여러 서비스를 경유하는 추저을 분석하고 병목점을 감지하며, 처음에는 묻고 싶지 않았던 시스템에 대한 질문을 할 수 있게 도와준다.

### 4-2. 컨테이너와 쿠버네티스

- 각 마이크로서비스 인스턴스를 격리해 실행하는 것은 이상적이다. 이렇게 하면 한 마이크로서비스의 문제가 다른 마이크로서비스에 영향을 미치지 않게 할 수 있다.
- `가상화 virtualization`는 기존 하드웨어에 격리된 실행 환경을 만드는 한 가지 방법이지만, 일반적인 가상화 기술은 마이크로서비스 크기를 고려할 때 상당히 무거울 수 있다.
    - 반면에 컨테이너는 서비스 인스턴스를 위한 격리된 실행 환경을 프로비저닝하는 훨씬 더 가벼운 방법을 제공하므로 많은 아키텍처에서 비용 효율도 훨씬 더 높을 뿐 아니라 새로운 컨테이너 인스턴스의 시작 시간도 더 빨라진다.
- 쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼은 이에 꼭 맞는 일을 수행하는데, 하위 머신을 효율적으로 사용하면서 서비스에 요구되는 견고함과 처리향을 제공하는 방식으로 컨테이너를 분산시킨다.

### 4-3. 스트리밍

- 마이크로서비스로 인해 모놀리식 데이터베이스에서 멀어지고 있지만 여전히 마이크로서비스 간에 데이터를 공유하는 방법을 찾아야 한다.
- 많은 사람에게 아파치 카프카는 다양한 이유로 마이크로서비스 환경에서 데이터를 스트리밍하기 위한 실질적인 선택지가 됐다.
    - 메시지 영구성, 압축, 대용량 메시지를 처리할 수 있는 확장 기능 등이 매우 유용하다.
    - 아파치 플린크와 같은 전용 스트림 프로세싱 솔루션도 함께 사용할 수 있다.

### 4-4. 공용 클라우드 및 서버리스

- 구글 클라우드, 마이크로소프트 애저, 아마존 웹 서비스 3개의 주요 제공업체에서 다양한 관리형 서비스와 배포 옵션을 사용할 수 있다.
- 마이크로서비스가 더 늘어나면 더 많은 작업이 점차 운영 영역으로 이동될 것이다.
    - 공용 클라우드 제공업체는 관리형 데이터베이스 인스턴스나 쿠버네티스에서 메시지 브로커나 분산 파일 시스템에 이르기까지 많은 관리형 서비스를 제공한다.
    - 관리형 서비스를 사용하면 이러한 작업을 더 잘 처리할 수 있는 제삼자에게 많은 양의 작업을 넘길 수 있다.
- 공용 클라우드 제품 중 특히 흥미로운 것은 `서비리스 serverless`라는 구호 아래에 있는 제품들이다.
    - 하부 머신을 숨겨 더 높은 추상화 수준에서 작업할 수 있게 도와준다.
    - 제품의 예로는 메시지 브로커, 스토리지 솔루션, 데이터베이스 등이 있다.

<br/>

## 5. 마이크로서비스의 장점

- 정보 은닉과 도메인 지향 설계의 개념을 분산 시스템의 역량과 결합함으로써 마이크로서비스는 다른 형태의 분산 아키텍처에 비행 상당한 이점을 제공할 수 있다.

### 5-1. 기술 이질성

- 다수의 협력하는 마이크로서비스로 구성된 시스템이라면 각 마이크로서비스에 서로 다른 기술을 사용하기로 결정할 수 있다.
    - 이렇게 함으로써 각 작업에 적합한 도구를 선택할 수 있어 표준화되고 최소 공통 분모로 끝나버리는 획일적인 접근 방식을 선택하지 않아도 된다.
- 시스템의 한 부분의 성능을 개선하기 위해서 더 나은 기술 스택을 사용하도록 결정하기도 한다.
    - 또한 데이터를 저장하는 방식으로 인해 시스템의 다른 부분을 변경할 수도 있다.
    - 예를 들면 소셜 네트워크의 경우, 소셜 그래프의 고도 상호 연결성을 반영하기 위해 그래프 지향 데이터베이스에 사용자의 상호작용을 저장할 수 있지만, 사용자가 작성한 게시물은 문서 지향 데이터 저장소에 저장하기도 한다.
- 마이크로서비스를 사용하면 기술을 더 빨리 채택할 수 있고 새로운 기술 발전이 어떻게 도움이 되는지 이해할 수 있다.
    - 모놀리식 애플리케이션에서 새로운 프로그래밍 언어, 데이터베이스 또는 프레임워크를 시험한다면 변경 사항이 시스템의 많은 부분에 영향을 미치게 된다.
    - 여러 서비스로 구성된 시스템은 새로운 기술을 시험해볼 새로운 장소가 여러 개 생기며, 혹시 모를 부정적인 영향을 제한하고자 위험이 가장 낮을 것 같은 마이크로서비스를 골라 기술을 적용할 수 있다.
- 물론 여러 기술을 수용하기에는 오버헤드가 있을 것이다.

### 5-2. 견고성

- 애플리케이션의 견고성을 향상시키는 핵심 개념은 `벌크헤드 bulkhead`다.
    - 시스템의 구성 요소 중 하나가 고장날 수 있지만, 그 고장이 연속적으로 발생하지 않는 한 문제를 격리하고 나머지 시스템은 계속 작동할 수 있다.
    - 서비스 경계는 명백한 벌크헤드(격벽)가 된다.
- 모놀리식 시스템의 경우 여러 머신에서 실행시켜 고장 가능성을 줄일 수 있지만, 마이크로서비스를 사용하면 일부 구성 서비스의 전체 장애를 처리하고, 그에 따라 기능을 저하시키는 시스템을 구축할 수 있다.
    - 반드시 주의해야 한다. 마이크로서비스 시스템이 향상된 견고함을 수용할 수 있도록 하려면 분산 시스템이 처리해야 할 새로운 고장 원인을 이해해야 한다.
    - 네트워크는 기계와 마찬가지로 고장날 수 있고 결국 고장날 것이다. 따라서 그러한 고장을 처리하는 방법과 그러한 실패가 소프트웨어의 최종 사용자에게 미칠 영향을 알아야 한다.

### 5-3. 확장성

- 대규모 모놀리식 서비스에서는 모든 것을 함께 확장해야 한다.
- 전체 시스템의 작은 한 부분에 성능 제약이 있어서 해당 동작이 거재한 모놀리식 애플리케이션에서 확장이 제한된다면 모든 것을 한 덩이로 확장해야 한다.
    - 더 작은 서비스를 사용하면 확장이 필요한 서비스만 확장할 수 있으므로 시스템의 다른 부분을 더 작고 성능이 낮은 하드웨어에서 실행하게 된다.

### 5-4. 배포 용이성

- 무려 100만 줄에 달하는 모놀리식 애플리케이션은 한 줄만 수정하더라도 변경 사항을 릴리스하기 위해 전체 애플리케이션을 배포해야 한다.
    - 이는 미치는 영향이 크고 매우 위험한 배포가 될 수 있다.
    - 결국 릴리스 간의 변화 폭이 클수록 무언가 잘못될 가능성도 함께 높아진다.
- 마이크로서비스를 이용하면 하나의 서비스만 변경하고 시스템의 다른 부분과는 독립적으로 배포할 수 있다.
    - 이렇게 하면 코드를 더 빠르게 배포할 수 있으며, 문제가 발생하더라도 빠른 롤백을 수행해 신속하게 해당 문제를 개별 서비스로만 제한할 수 있다.
    - 결과적으로 고객에게는 새로운 기능을 더 신속하게 전달하게 된다.

### 5-5. 조직적 정렬

- 대규모 팀 및 코드베이스와 관련된 문제를 한 번쯤은 경험해봤을 것이다. 이러한 문제는 팀이 분산되면 더 악화되며 더 작은 코드베이스로 일하는 더 작은 팀이 더 생산적인 경향이 있다는 사실도 알고 있다.
- 마이크로서비스를 이용하면 아키텍처를 조직 구조에 맞게 더 적절히 정렬할 수 있고, 팀 크기와 생산성의 최적점에 도달하기 위해 하나의 코드베이스에서 일하는 인원을 최소화할 수 있다.
- 또한 조직 변경에 따라 서비스의 소유권도 바꿀 수 있어 향후 아키텍처와 조직 간의 정렬 상태를 유지할 수 있다.

### 5-6. 조합성

- 분산 시스템과 서비스 지향 아키텍처가 보장하는 핵심 효용 중 하나는 재사용할 기회가 많다는 것이다.
- 마이크로서비스를 통해 기능을 다양한 목적과 방식으로 사용할 수 있으며, 이는 소비자가 소프트웨어를 어떻게 소비하는지 생각할 때 매우 중요하다.

<br/> 

## 6. 마이크로서비스의 고충

- 좋은 점과 나쁜 점을 비교하는 것이 중요하다.

### 6-1. 개발자 경험

- 점점 더 많은 서비스가 생기면 개발자의 고된 경험이 시작된다.
    - JVM과 같은 리소스 집약적인 런타임은 하나의 개발자 머신에서 실행 가능한 마이크로서비스의 수를 제한한다.
    - 런타임이 무겁기 때문에 많은 서비스를 실행할 수 없다.

### 6-2. 기술 과다

- 다양한 기술이 가져올 비용과 사용하는 기술의 범위 및 복잡성을 신중하게 저울질해야 한다.
- 마이크로서비스를 도입하기 시작하면 피할 수 없는 몇 가지 근본적인 문제가 따른다.
    - 따라서 데이터 일관성, 지연 시간, 서비스 모델링 등과 관련된 문제를 이해하는 데 많은 시간을 할애해야 한다.
    - 엄청난 양의 새로운 기술을 수용하는 동시에 그 개념이 소프퉤어 개발에 대한 생각을 어떻게 바꾸는지 이행하려고 하면 어려움을 겪게 될 것이다.

### 6-3. 비용

- 단기적으로 여러 요인으로 인해 비용이 증가할 가능성이 높다.
    - 더 많은 프로세스, 더 많은 컴퓨터, 더 많은 네트워크, 더 많은 스토리지, 더 많은 지원 소프트웨어
- 팀이나 조직에 변경이 발생하면 단기적으로 속도가 느려진다는 점도 중요하다.
    - 새로운 개념을 배우고 효과적으로 사용하는 방법을 익히는 데는 시간이 걸린다.
- 마이크로서비스는 주로 비용 절감에 관심을 둔 조직에는 적합하지 않다.
- 마이크로서비스는 더 많은 수익을 창출하는 방법이 될 수는 있지만 비용을 줄이는 방법이 되진 않는다.

### 6-4. 리포팅

- 모놀리식 시스템에는 일반적으로 모놀리식 데이터베이스가 있다.
    - 흔히 데이터 간 대규모 조인 작업으로 얻은 모든 데이터를 분석하길 원하는 이해관계자는 보고서를 실행하기위해 미리 만들어둔 스키마를 갖고 있다는 의미다.
- 마이크로서비스 아키텍처에서는 이 모놀리식 스키마를 분해했다.
    - 그렇다고 해서 모든 데이터를 활용한 리포팅이 불필요해진 것은 아니다.
    - 이제 데이터가 논리적으로 분리된 여러 스키마에 분산돼 있기 때문에 리포팅을 실행하기 더 어려워졌다.

### 6-5. 모니터링과 문제 해결

- 표준 모놀리식 애플리케이션의 모니터링은 꽤 단순한 접근 방법을 취할 수 있다. 걱정해야 할 머신의 수도 적고 애플리케이션의 실패 유형도 대개 업 또는 다운과 같이 다소 이분법적이다.
- 마이크로서비스 아키텍처를 사용하는 경우, 단일 인스턴스가 다운될 때 미치는 영향을 알고 있는가? (복잡성)

### 6-6. 보안

- 중간자 공격으로 데이터가 조작될 가능성이 더 높아진다.
- 즉 전송 중인 데이터와 마이크로서비스 엔드포인트를 보호해 권한 있는 당사자만 사용할 수 있도록 보장하는 데 더 많은 주의를 기울여야 한다.

### 6-7. 테스팅

- 테스트의 범위가 커질수록 테스트 데이터 및 테스트 지원용 픽스처 설정이 어려워지고, 실행하는 데 더 오랜 시간이 걸리며, 테스트가 실패했을 때 깨진 부분을 파악하기도 더 어려워질 수 있다.
- 마이크로서비스의 e2e 테스트는 범위가 상당히 넓다.

### 6-8. 지연 시간

- 한 프로세서로 수행하던 처리를 여러 개별 마이크로서비스로 불할해 처리할 수 있다.
    - 각 서비스는 데이터를 직렬화하고 전송해야 하며, 수신할 때는 역직렬화해야 한다.
    - 이 모든 것은 시스템의 지연 시간을 악화시킨다.
- 마이크로서비스 이전을 점진적 방식으로 수행해야 하는 또 다른 중요한 이유가 된다.
    - 약간의 변경을 적용한 다음 그 영향도를 측정하라.

### 6-9 데이터 일관성

- 모놀리식 시스템에서는 데이터베이스 트랜잭션에 의존할 수 있었지만, 분산 시스템에서는 유사한 안전성을 쉽게 제공할 수 없다는 점을 이해해야 한다.
- 대부분의 경우 분산 트랜잭션을 사용하면 상태 변경을 조정하는 데 매우 큰 문제가 있는 것으로 나타났다.

<br/>

## 7. 마이크로서비스를 사용해야 하는가?

- 앞서 설명한 많은 문제를 고려해 도입 여부를 신중히 결정해야 한다.
- 마이크로서비스가 자신에게 적합한지 판단하기 전에 문제 영역, 기량, 기술 상황을 평가하고 달성하려는 목표가 무엇인지 이해해야 한다.

### 7-1 마이크로서비스가 적합하지 않은 곳

- 마이크로서비스 아키텍처는 새로운 제품이나 스타트업 기업에는 적합하지 않은 선택이다.
    - 어느 경우든, 작업 중인 도메인은 구축하려는 기본 사항을 반복하면서 통상 엄청난 변화를 겪고 있다.
    - 도메인 모델이 변화하면 결과적으로 서비스 경계가 더 많이 변경되며, 이 경계를 넘어 변경을 조정하는 작업은 많은 비용이 든다.
    - 일반적으로 서비스 경계를 정의하기에 앞서 도메인 모델이 충분히 안정화될 때가지 기다리는 것이 더 적절하다.
- 스타트업은 일반적으로 시스템을 구축할 사람이 적으므로 마이크로서비스와 관련해 더 많은 도전이 발생한다.
    - 팀이 작을수록 이 비용은 더 많이 발생한다.
    - 그래서 어떤 사람들은 이를 `마이크로서비스 세금 microservice tax`라고도 한다.

### 7-2. 마이크로서비스가 적합한 곳

- 마이크로서비스를 도입하는 가장 큰 이유는 더 많은 개발자가 서로 방해하지 않고 동일 시스템에서 작업하기 위해서다.
    - 아키텍처와 조직의 경계를 올바르게 설정하면 더 많은 사람이 서로 독립적으로 작업하도록 전달 경합 문제를 줄일 수 있다.
- `Sofeware as a Service, SaaS` 애플리케이션은 일반적으로 마이크로서비스 아키텍처에도 잘 맞는다.
    - 이런 제품은 보통 24시간 연중무휴로 작동해야 하므로 변경 사항을 배포할 때 어려움이 있다.
    - 독립적 릴리스가 이 분야에서 힘을 발휘한다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
