# Chapter 9 테스트

- 기능이 분산 시스템에 걸쳐 있을 때 코드의 기능을 효과적이고 효율적으로 테스트하는 방법?
- 소프트웨어를 가능한 한 빨리 운영 환경에 보내려는 주장 vs 소프트웨어의 품질이 충분한 수준인지 확인하려는 주장
    - 실행 가능한 테스트 유형을 이해하여 둘 간의 균형을 잡는다.

## 1. 테스트 유형

- 인수 테스팅: 프로그래밍 지원, 비즈니스 대면
    - 맞는 것을 빌드했는가?
    - 자동화(Fit-Fitnesse 등)
- 탐색 테스팅: 제품 평가, 비즈니스 대면
    - 사용성: 어떻게 시스템을 중단시킬 수 있는가?
    - 수동
- 단위 테스팅: 프로그래밍 지원, 기술 대면
    - 제대로 빌드했는가?
    - 자동화(xUnit 프레임워크)
- 속성 테스팅: 제품 평가, 기술 대면
    - 응답 시간, 확장성, 성능, 보안 도구

> #### 수동 탐색 테스팅
> - 수동 탐색 테스트는 잘 수행되면 발견에 큰 도움이 된다.
> - 최종 사용자로서 애플리케이션을 탐색할 시간을 따로 설정하면 분명하지 않은 문제를 발견할 수 있다.
> - 수동 테스팅은 아마도 테스트 작성 비용 때문에 자동화된 테스트를 구현하지 못하는 상황에서 매우 중요할 수 있다.
> - 자동화는 반복적인 작업을 제거해 인간이 더 창의적이고 특별한 활동을 하도록 해준다. 따라서 자동화를 가장 잘할 수 있는 일에 집중하는 방법이라고 생각하라.

<br/>

## 2. 테스트 범위

- UI(e2e)  <------->  서비스  <------->  단위
- 테스트 범위 증가 <--------------------------
- --------------------> 더 빠르다. 더 나은 격리

- 피라미드에서 올라갈수록 테스트 범위가 증가하고 테스트 중인 기능이 작동한다는 확신도 커진다.
    - 하지만 오랜 시간 + 피드백 주기 시간 증가 + 실패 했을 때 어떤 기능이 손상됐는지 확인하기 어려움.
- 아래로 내려갈수록 테스트가 빨라지고 피드백 주기도 훨씬 짧아진다. 고장 난 기능을 더 빨리 발견 + 지속적 통합 빌드 빨리짐 + 고장난 것을 발견하기 전에 새 작업으로 이동할 가능성이 줄어듬. 또한 실패했을 때 원인 파악이 빠름. 격리성이 높아 고장을 이해하고 수정하기 쉽다.
    - 시스템 전체가 제대로 작동한다고 확신할 수 없다.

### 2-1. 단위 테스트

- 마이크로서비스를 시작하지 않아도 된다.
- 1분도 안 되는 시간에 수천 개 실행 가능.
- 단위 테스트의 핵심 목표는 기능이 정상적으로 작동하는지에 대한 매우 빠른 피드백을 제공.
- 코드 리팩토링을 지원. 이게 중요!!

### 2-2. 서비스 테스트

- 개별 마이크로서비스의 기능을 테스트.
- 서비스가 예상대로 작동한다고 더욱 확신할 수 있지만, 테스트 범위는 여전히 어느 정도 격리돼 있다.
- 테스트 실패의 원인은 테스트 중인 마이크로서비스로 제한돼야 한다.
- 실패할 경우, 단위 테스트보다 문제가 있는 부분을 감지하기 어렵다.
- 하지만 동작 구성 요소가 훨씬 적으므로 더 광범위한 테스트보다 취성(깨지기 쉬운 성질)이 낮다.

### 2-3. 엔드투엔드 테스트

- 시스템 전체에 대해 수행.
- 범위가 늘어나 불리해지는 부분이 존재

### 2-4. 절충안

- 유형별 테스트 수를 알맞게 조절해야 할 경우가 많다.
    - 피라미드 형태처럼 단위 테스트 많이, 서비스 적당히, UI 적게
- 안티 패턴 => 테스트 아이스크림콘 혹은 역피라미드.
    - 작은 범위의 테스트가 거의 없으며 넓은 범위의 테스트에서 모든 영역을 커버하고 있다.
    - 테스트가 매우 느리게 수행되고 피드백 주기가 매우 길다.

<br/>

## 3. 서비스 테스트의 구현

- Mock & Stub

<br/>

## 4. 까다로운 엔드투엔드 테스트의 구현

- 엔드투엔드 테스트를 구현하려면 모든 마이크로서비스를 배포해야 한다.
- 모든 마이크로서비스의 빌드가 성공하면 공유된 엔드투엔드 테스트 단계를 트리거한다.
- 하지만 e2e 테스트는 많은 단점이 있다.

### 4-1. 불안정하고 깨지기 쉬운 테스트

- 작동하는 구성 요소가 많을수록 테스트는 더 불안정해지고 더 결정적이지 못할 수 있다.
- 불안정한 테스트를 감지하면 이를 제거하기 위해 최선을 다하는 것이 중요하다. 그렇지 않으면 '항상 그렇게 실패하는' 테스트 집합에 대해 불신이 싹트게 된다.
    - `비정상의 정상화 normalization of deviance`. 시간이 지남에 따라 잘못된 것에 너무 익숙해져서 문제가 아닌 정상적인 것으로 받아들이게 되는 현상.
    - 문제는 최대한 빠르게 제거하자.

### 4-2. 누가 e2e 테스트를 작성하는가?

- 합리적인 출발점. 해당 서비스를 소유한 팀이 해당 테스트를 작성.
- 하지만 e2e는 여러 팀이 관련돼 있다. 그럼 누가 그 테스트를 작성하고 관리할까?
    - 여기서 문제가 발생한다.
    - 모든 팀이 전체 테스트 집합의 상태를 전혀 이해하지 못한 채 테스트를 추가할 수 있는 액세스 권한을 부여받아 난장판이 된다.
    - 이로 인해 종종 테스트 케이스가 폭발적으로 증가. 때로는 테스트 아이스크림콘이 형성.
- 때로는 조직에서 테스트 작성 전담 팀을 둬 대응 => 이 방식은 재앙을 초래할 수 있다.
    - 소프트웨어를 개발하는 팀은 코드 테스트에서 점점 더 멀어지기 때문이다.

### 4-3. e2e 테스트는 얼마나 오래 걸릴까?

- 꽤 오래 걸린다. 길게는 하루.
- 어떤 프로젝트에서는 전체 회귀 테스트 집합을 실행하는 데 6주라는 시간.
- 필요없는 테스트는 제거해야 한다.
    - 하지만 테스트 제거는 때때로 걱정스런 작업.
    - 만약 버그를 허용한다면 비난이 따를 것이 분명.

### 4-4. 대규모 적체

- 고장난 통합 테스트 단계를 수정하는 동안 업스트림 팀의 더 많은 변경이 누적될 수 있다.
    - 빌드 수정은 힘들어지고, 배포할 변경 사항의 범위도 늘어난다.

### 4-5. 메타버전

- 여러 서비스를 함께 버전 관리? => 다른 서비스와 독립적으로 배포할 수 있는 능력을 잃어 버리게 된다.

### 4-6. 독립적인 테스트 가능성 부족

- e2e 테스트
    - 때로는 팀의 자율성을 감소
    - 테스트가 수반하는 연관 문제와 함께 조율 수준을 더욱 높이도록 강요.

<br/>

## 5. e2e 테스트를 피해야 할까?

### 5-1. 계약 테스트와 소비자 주도 계약

- 계약 테스트를 사용하면 마이크로서비스가 외부 서비스를 사용하는 팀은 외부 서비스의 기대 작동 방식을 설명하는 테스트를 작성한다.
    - 자체 마이크로서비스를 테스트하는 것이 아니라 외부 서비스의 작동 방식을 지정하는 것이다.
    - 외부 서비스를 대리하는 데 사용되는 스텁과 목에서 수행할 수 있다는 점도 이러한 계약 테스트가 유용해진 한 가지 주된 이유다.
- 계약 테스트는 `소비자 주도 계약 consumer-driven contract, CDC`의 일부분으로 사용될 때 매우 유용하다.
    - 계약 테스트는 사실상 소비자(업스트림) 마이크로서비스가 생산자(다운스트림) 마이크로서비스에 기대하는 동작 방식을 명시적인 프로그래밍 방식으로 표현한 것이다.
    - CDC를 통해 소비자 팀은 마이크로서비스가 이와 같은 기대치를 충족하는지 확인할 수 있다.
- 서비스 테스트와 동일한 효과의 테스트 범위를 가지기 때문에 성능 특성이 비슷하고 외부 종속성이 제거된 마이크로서비스 자체만 실행해야 한다.

#### 팩트 Pact

- Pact. 소비자 주도의 테스팅 도구. 오픈소스.
- DSL을 사용해 제작자의 기대 사항을 정의하는 것에서 시작.
- 팩트 브로커를 통해 여러 다른 버전의 소비자에 대해 소비자 주도 계약 테스트를 실행할 수 있다.

#### 다른 대안

- 팩트가 소비자 주도 계약을 위한 유일한 도구는 아니다.
- 스프링 클라우드 컨트랙 => 순수 JVM 생태계에서만 가용.

#### 대화가 중요해

- 애자일에서 Story는 종종 대화의 영역으로 자주 언급되면, CDC가 바로 그런 것이다.
- 제삼자가 제공하는 서비스를 사용하는 경우 CDC를 동작시키기 위한 의사소통이나 신뢰의 기회를 자주 갖지 못할 수도 있다.
    - 신뢰할 수 없는 구성 요소를 포함해 더 큰 범위의 제한된 통합 테스트를 수행해야 할지도 모른다.

### 5-2. 결론

- e2e 테스트는 구성 요소가 더 많이 추가됨에 따라 단점이 많아진다.
    - 시간이 지남에 따라 소프트웨어 품질을 검증하는 다른 메커니즘을 선호.

<br/>

## 6. 개발자 경험

- 더 많은 마이크로서비스 -> 개발자 경험에서 어려움.
- 로컬에서 더 많은 마이크로서비스를 실행하려고 하기 때문.
    - 스텁되지 않은 여러 마이크로서비스를 연결하는 넓은 범위의 테스트를 실행해야 하는 상황에서 자주 발생.
- 완전히 클라우드에서 개발하는 것은 피드백 주기 문제를 해결하는 한 가지 해법이다.
    - AWS가 소유한 Cloud9과 같은 클라우드 기반 IDE. 하지만 대다수 사람들의 현실과는 확실히 거리가 멀다.
- 한 팀에서 마이크로서비스 5개를 보유하고 있다면, 해당 서비스를 가능한 한 효과적으로 실행할 수 있어야 하며, 빠른 피드백을 위해 항상 로컬에서 실행하는 것이 좋다.
    - 하지만 팀이 다르다면? 로컬 개발 및 테스트 환경이 작동하지 않을 것이다.
    - 여기서 스텁이 도움이 되며, 우리 팀 범위 밖에 있는 마이크로서비스를 모방하는 로컬 스텁을 만들 수 있어야 한다.

<br/>

## 7. 운영 전 테스트에서 운영 중 테스트로

- 테스트 = 소프트웨어 품질이 충분한지를 피드백하는 데 목적
- 이상적으로 가능한 한 빨리 피드백을 원하고 최종 사용자가 문제를 경험하기 전에 소프트웨어 문제가 있는지 파악하고 싶어 하는데, 소프트웨어를 릴리스하기 전에 많은 테스트를 수행하는 것도 바로 이런 이유 때문이다.
    - 하지만 사전 운영 환경에서만 테스트하도록 제한하는 것은 스스로의 발목을 잡는 일이다.
- 운영 환경에서는 테스트를 적용할지를 검토할 수 있으며, 반드시 그렇게 해야 한다.
    - 안전한 방식으로 수행될 수 있고, 더 높은 품질의 피드백을 제공할 수 있으며, 실감하든 아니든 이미 수행하고 있는 작업일 수 있다.

### 7-1. 운영 환경 테스트 유형

- `스모크 테스트 smoke test`
    - 배포된 소프트웨어가 올바르게 동작하는지 확인.
    - 일반적으로 릴리스되기 전에 실행 중인 실제 소프트웨어에서 수행.

### 7-2 운영 환경에서 안전한 테스트 만들기

- 테스트가 시스템 불안정을 가져오거나 운영 환경 데이터를 오염시켜 문제를 일으키지 않아야 한다.

### 7-3. MTBF보다 MTTR

- `평균 무고장 시간 Mean Time Between Failures`
- `평균 수리 시간 Mean Time to Repair`
- 복구 시간을 줄이는 기술은 우수한 모니터링과 결합돼 매우 빠른 롤백만큼 간단할 수 있다.
    - 문제를 조기에 발견하고 일찍 롤백할 수 있다면 고객에게 미치는 영향은 줄어든다.
- 처음에 발생하는 결함의 수는 줄일 수 있지만 모든 결함을 제거하지는 못하며, 운영 과정에서 결함이 나타날 경우 대처할 준비가 돼 있지 않다.

<br/>

## 8. 교차 기능 테스트

- Cross-functional requirement, CFR
- 속성 테스트 사분면에 속함. ex) 성능 테스트

### 8-1. 성능 테스트

- 호출 체인 일부가 느리게 작동하기 시작하면 모든 것이 영향을 받아 잠재적으로 전체 호출 체인에 심각한 영향을 미치게 된다.
    - 따라서 모놀리식 시스템일 때보다 애플리케이션 성능을 테스트하는 방법이 훨씬 중요해진다.
    - 이런 종류의 테스트가 지연되는 이유는 처음에는 테스트할 시스템이 충분하지 않기 때문이다.
- 기능 테스트와 마찬가지로 혼합하고 싶을 수 있다.
    - 개별 서비스를 격리해 성능 테스트를 하고 싶겠지만, 시스템의 핵심 전이를 확인하는 테스트부터 시작하라.
    - e2e 전이 테스트를 가져와 규모에 맞게 간단히 실행할 수 있다.
- 의미 있는 결과를 도출하기 위해 모의 고객 수를 점차 증가시키면서 주어진 시나리오를 수행해야 하는 경우가 많다.
    - 증가되는 부하에 따라 호출 지연 시간이 어떻게 변하는지 확인할 수 있으며, 이는 곧 성능 테스트를 실행하는 데 어느 정도 시간이 걸린다는 것을 의미한다.
- 최대한 운영 환경과 일치시키기
    - 데이터양 확보. 인프라스트럭처 일치. => 더 많은 시스템 필요. 힘든 작업.
- 결과를 확인하는 것을 잊지 말라.
    - 테스트를 구현하고 수행하는 데 많은 공을 들이지만 정작 그 결과를 확인하지 않는 경우가 많았다고 함.

### 8-2. 견고성 테스트

- 가장 약한 링크에 의해 신뢰성이 결정.
- 결과적으로 시스템 안정성을 향상시키기 위해 마이크로서비스가 자체적으로 `견고성 robustness`을 개선할 메커니즘을 구축하는 것이 일반적.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
