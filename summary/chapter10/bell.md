# Chapter 10. 모니터링에서 관찰가능성으로

- 마이크로서비스로 분해하면 여러 가지 이점도 있지만, 새로운 복잡성을 유발하는 원인이 되기도 함.
- 복잡성이 가장 명확하게 드러나는 상황은 운영 환경에서 시스템의 동작일 이해할 때.
    - 단일 프로세스형 모놀리스 애플리케이션에서 잘 작동했던 도구와 기술이 마이크로서비스 아키텍처에서는 적합하지 않다는 사실을 알게 될 것이다.

<br/>

## 1. 분열, 공황, 그리고 혼란

- 단일 프로세스형 모놀리스 애플리케이션.
    - 단일 장애 지점이 있으면 장애 조사가 다소 간단해진다.
- 마이크로서비스 기반 시스템.
    - 모니터링 세계에서는 문제가 더 복잡해진다.
    - 모니터링할 서버가 여러 대, 선별할 로그 파일도 여러 개, 네트워크 지연으로 인해 문제가 발생할 수 있는 장소도 여러 곳.
    - 고장이 발생할 수 있는 표면적도 늘어나 조사해야할 사항도 늘어났다.
    - 작은 것을 모니터링하고 더 큰 그림을 볼 수 있도록 `집계 aggregation`을 제공해야 한다.
    - 분석의 일환으로 이 데이터를 조각으로 나누는 도구가 있는지 확인
    - 끝으로, 운영 환경에서 테스트한다는 개념을 수용해 시스템 `정상 상태 health`에 대해 더 현명한 사고방식을 가져야.

<br/>

## 2. 단일 마이크로서비스, 단일 서버

- 호스트 자체의 정보: CPU, 메모리 등 모든 정보가 유용
- 인스턴스 자체에 출력되는 로그에 접근할 수 있어야 한다. => 사용자가 오류를 보고하면 오류를 볼 수 있어야 한다.
- 애플리케이션 자체를 외부에서 관찰.
    - 최소한의 수준으로 마이크로서비스의 응답 시간을 모니터링하는 것은 좋은 생각.

<br/>

## 3. 단일 마이크로서비스, 다수 서버

- 서버의 여러 복제본이 로드 밸런서를 통해 분산된 다른 인스턴스에 대한 요청.
- 이전처럼 전부 동일한 것을 모니터링하길 원하지만, 문제를 격리할 수 있는 방향으로 모니터링해야 한다.
    - 각각의 호스트뿐만 아니라 모든 호스트에 걸쳐 있는 것을 모두 확인해야 한다.
    - 모든 것을 집계하고 깊이 분석하길 원한다.
- 로그.
    - 여러 호스트에서 동일한 명령을 실행하는 SSH 멀티플렉서와 같은 도구를 사용할 수 있다.
    - 마이크로서비스 로그에서 `grep Error`라고 실행하면 범인(원인)을 찾게 된다.
- 응답 시간 추적
    - 다운스트림 마이크로서비스 호출에 대한 응답 시간을 로드 밸런서에서 수집할 수 있다.
    - 하지만 로드 밸런서가 시스템의 병목 지점으로 판명된다면 어떻게 되는지도 고려해야 한다.
    - 따라서 로드 밸런서와 마이크로서비스 두 곳에서 모두 응답 시간을 측정해야 할 수 있다.

<br/>

## 4. 다수 마이크로서비스, 다수 서버

- 정보 수집(메트릭과 로그)은 이를 실현하는 데 중요한 역할을 하지만, 고려해야 할 유일한 것은 아니다.
    - 엄청난 양으로 유입되는 데이터를 어떻게 선별하고 모든 것을 이해하려고 노력해야 한다.
    - 정적인 모니터링 환경에서 보다 적극적인 관찰가능성과 운영 환경에서의 테스트로 사고방식을 전환하는 것에 관련.

<br/>

## 5. 관찰가능성 대 모니터링

- `관찰가능성 observability`
    - 잘 관찰될수록 무언가 잘못됐을 때 문제를 이해하기가 더 쉬워진다.
    - 외부 출력을 이해할 수 있다면 근본적인 문제를 더 빨리 추적할 수 있다. => 단 외부 출력을 생성하고 다양한 도구를 사용해 출력을 이해하는 일은 결코 쉽지 않다.

### 5-1. 관찰가능성의 주축? 그다지 빠르지 않다

- 일부는 메트릭, 로깅, 분산 추적의 형태로 구분한 관찰가능성의 '세 가지 주축'에 중점을 뒀다.

1. 시스템의 속성을 구현 세부 사항으로 축소하는 것이 필자에게는 퇴보하는 것처럼 보임.
2. 이러한 개념 사이에 언제나 구체적인 경계가 존재할까? 많은 부분이 겹치고, 필요하다면 메트릭을 로그 파일에 삽입할 수 있다.

- 냉소적 입장.
    - 이렇게 단순하게 설명하는 것은 도구 판매를 위한 수단이라고 생각.
    - 메트릭 => 도구 하나. 로그 => 도구 하나. 추적 => 도구 하나.

<br/>

## 6. 관찰가능성의 구성 요소

### 6-1. 로그 집계

- 규모가 크지 않은 마이크로서비스 아키텍처에서도 서버와 마이크로서비스 인스턴스가 많기 때문에 머신에 로그인하거나 `SSH 다중화 SSH-multiplexing`를 통해 로그를 검색하는 것만으로는 충분하지 않다.
    - 대신 특수한 하위 시스템을 사용해 로그를 수집하고 중앙에서 사용할 수 있게 하려고 한다.
- 다양한 도구.
    - 로컬 파일 시스템에 로그를 기록
    - 로커 데몬 프로세스는 주기적으로 이 로그를 수집해 운영자가 쿼리할 수 있는 일종의 저장소로 전달.
- 마이크로서비스 아키텍처를 구현하기 위한 전제 조건으로 로그 집계 도구의 구현을 바라봐야 한다.
    1. 로그 집계는 유용하다.
    2. 난이도가 낮다.

#### 공통 포맷

- 날짜, 시간, 마이크로서비스 이름, 로그 레벨 등. 각 로그의 일관된 위치에 있어야 함.

#### 로그 문자열의 상관관계

- 최종 사용자 기능을 제공하기 위해 많은 서비스가 상호작용하는 경우, 처음에는 하나로 시작한 호출이 여러 다운스트림 호출을 생성할 수 있다.
- 유용한 접근법.
    - 상관관계 ID를 사용.
    - 첫 번째 호출이 이뤄지면, 요청과 관련된 모든 후속 호출을 연관시키는 데 사용할 고유 ID를 생성.
    - 게이트웨이에서 이 ID를 생성하고 나면 해당 ID가 후속 호출에 매개변수로 전달.
- 물론 각 서비스가 상관관계 ID를 전달하는 것을 알고 있는지 확인해야 한다.
    - 표준화 강조.
    - 이 도구는 `이벤트 폭풍 event storm` 또는 이상한 지엽적인 사례를 추적하거나 호출의 전 단계를 보여줄 수 있으므로 특히 비용이 많이 드는 트랜잭션을 식별하는 데 유용.

#### 타이밍

- 로그 문자열 리스트를 볼 때, 무슨 일이 어떤 순서로 발생했는지 이해하고 있다고 착각하기 십상.
- 사건이 발생한 순서를 결정하는 방법으로 사용할 수 없는 이유?
    - 서로 다른 시스템의 시계가 동기화돼 있다고 보장하지 못함. (머신의 시계)
    - 시스템 시간의 오차를 줄이는 프로토콜 존재 -> `Network Time Protocol, NTP`

#### 구현

- 로그 집계만큼 치열한 분야는 없다. 다양한 솔루션 존재.
- 가장 인기 있는 오픈소스 툴체인은 `Fluent`와 같은 로그 전달 에이전트를 사용해 로그를 `ElasticSearch`로 전송하고 `Kibana`를 결과로 발생된 로그 스트림을 분할하고 분석하는 용도로 사용하는 것.
- 두 가지 주의 사항
1. 검색 인덱스로 간주된 항목을 항상 데이터베이스로 변경하는 것은 매우 문제가 될 수 있다. (ElasticSearch != Database)
2. Elastic 회사의 문제.

#### 단점

- 로그만큼 투자 대비 효과가 좋은 곳은 거의 없다고 확신
- 하지만 몇 가지 문제
1. 시간 왜곡으로 인해 호출이 발생한 순서를 이해하는 과정에서 로그를 항상 신뢰할 수는 없다.
- 지연 시간 병목 지점을 추적하는 데 로그의 유용성이 제한.
2. 더 많은 마이크로서비스 => 더 많은 호출 => 엄청난 양의 데이터
- 더 많은 하드웨어 자원이 필요해짐. => 비용으로 연결.
3. 원하는 양의 로그를 저장하는 솔루션이 있더라도 중요하고 민감한 정보가 포함될 수 있다.
- 로그에 대한 액세스 제한이 필요할 수도.
- 로그가 악의적인 당사자의 목표가 되기도 한다.

### 6-2. 메트릭 집계

- 더 복잡한 시스템에 대한 메트릭을 볼 때는 '정상' 상태가 무엇인지 알기 어려울 것이다.
- 당황할 때와 안심할 때를 아는 비결은 명확한 패턴이 드러날 정도로 충분히 오랜 시간 동안 시스템이 어떻게 작동하는지에 대한 메트릭(지표)을 수집하는 것이다.
- 메타데이터를 메트릭과 연관 지을 수 있어야 함.
- 추세를 이해하면 얻게 되는 또 다른 주요 이점은 `용량 계획 capacity planning`
    - 추세를 더 똑똑하게 추적하고 더 영리하게 처리하는 방법은 숙지할수록 시스템의 비용 효율성과 반응성을 높일 수 있다.
- 응답 시간, CPU 디스크 공간 사용량과 같은 단순한 정보로부터 캡처하려는 정보 유형을 더 광범위하게 생각하면 상황은 흥미로워지기 시작한다.

#### 낮은 카디널리티 vs 높은 카디널리티

- 메트릭이 디스크에 저장되는 방식 때문에 모든 태그를 작성하는 쓰기 작업은 폭발적으로 증가
    - 메트릭을 저장하는 것은 매우 저렴하지만 태그를 저장하는 데는 많은 비용.
    - 메트릭당 많은 태그를 저장하면 스토리지 엔진이 빠르게 중단된다.
- 실제로 낮은 카디널리티를 염두에 두고 구축된 시스템은 더 높은 카디널리티 데이터를 시스템에 넣으려고 할 때 큰 어려움을 겪을 것이다.
    - 프로메테우스 => 해당 시스템의 CPU 사용률과 같은 매우 단순한 정보를 저장하도록 구축.
    - 하지만 더 높은 카디널리티 데이터를 지원하는 기능이 부족.

#### 구현

- 예전이라면 그라파이트 사용을 권장했을지 모르지만, 프로메테우스가 합리적 대안.

### 6-3. 분산 추적

- 앞에서는 격리된 정보 수집에 대한 이야기.
- 기본적으로 마이크로서비스 아키텍처는 일종의 작업을 수행하기 위해 함께 작동하는 일련의 프로세스.
- 시스템이 복잡해짐에 따라 시스템에서 흔적을 보는 방법이 중요해짐.
    - 서로 다른 데이터를 가져와 상호 연관된 호출을 함께 볼 수 있어야 한다.
    - 상관관계 ID를 로그 파일에 삽입하는 등의 간단한 작업을 수행하는 것은 좋은 시작이지만, 특히 시각화하고 쪼개어 분석하기 위해 자체 맞춤형 도구를 만드는 점을 고려하면 이는 꽤 단순한 방법. 여기에서 분산 추적이 시작.

#### 작동원리

- 상세한 구현 방식은 서로 다르겠지만, 모두 유사한 방식으로 작동.
- 스레드 안의 로컬 활동은 `Span`으로 캡처. 각각의 `Span`은 일부 고유 식별자를 사용해 연결되며, 하나의 `Trace`로 구성되도록 중앙 수집기로 전송.
- 각 `Span`에는 시작 및 종료 시간, `Span`과 연관된 로그, 나중에 쿼리하기 위한 임의의 키-값 짝들의 집합이 포함.
- 시스템을 계속 운영하려면 추적 수집에서 일부 정보를 명시적으로 제외하는 샘플링이 필요.
    - 문제는 올바른 정보를 삭제하고 관찰 결과를 올바르게 추론하도록 충분한 샘플을 계속 수집하는 것.
- 샘플링 전략
    - 매우 기본적. 특정 퍼센트 호출이 샘플링.
    - 여기서 핵심은 시스템 자체가 처리하지 못할 정도로 많은 정보를 캡처하지 않는 것이다.

#### 분산 추적 구현

- 시스템에 대한 분산 추적을 가동시키려면 몇 가지 사항이 필요.
    1. 마이크로서비스 내에서 `Span` 정보를 캡처
    2. `Span` 정보를 수집기로 보낼 방법이 필요. 로컬 전달 에이전트를 사용하는 것이 일반적.
    3. 이 정보를 수신하고 모든 정보를 이해할 수 있는 수집기 필요

### 6-4. 잘하고 있나요?

- 과도하게 수행하고 있는지, 아니면 충분하지 못한지 어떻게 알 수 있을까?
- 작업을 충분히 잘 수행하고 있는지, 시스템이 충분히 잘 작동하고 있는지 어떻게 알 수 있을까?
- 수용 가능한 동작이 무엇인지라는 측면에서 좀 더 생각해볼 필요가 있다.
    - `사이트 안정성 엔지니어링, SRE` 분야에서 많은 작업이 이뤄지고 있음.

#### 서비스 수준 계약

- `SLA, Service-level agreement`
- 시스템을 구축하는 사람과 시스템을 사용하는 사람 사이의 게약.
- 시스템이 허용 가능한 동작 수준에 도달하지 못할 경우 발생하는 상황도 설명.

#### 서비스 수준 목표

- SLA가 다소 광범위하고 교차하는 경우?
- 대안. `SLO, Service-level objective`.
- SLO는 팀이 제공하기로 계약한 것을 정의. 조직 내 모든 팀의 SLO를 달성하면 조직의 SLA 요구 사항을 충족할 수 있다.

#### 서비스 수준 지표

- SLI, Service-level indicator
- 소프트웨어가 수행하는 작업의 척도.

#### 오류 예산

- `error budget`
- 새로운 것을 시도할 때는 시스템에 더 많은 잠재적 불안정을 주입하게 된다.
- 오류 예산은 시스템에서 허용되는 오류의 양을 명확하게 해서 이 문제를 피하려는 시도다.
- 오류 예산은 SLO를 얼마나 잘 달성하고 있는지 명확하게 파악하는 데 도움이 된다.
    - 또한 어떤 위험을 감수해야 하는지도 더 합리적으로 결정하게 된다.

### 6-5 알림

- 종종, 인간 운영자에게 조치를 취하라는 `알림 alert`이 필요한 일이 시스템에서 발생한다.

#### 어떤 문제는 다른 문제보다 훨씬 심각하다.

- 잠재적인 문제 요인이 증가하면 어떤 유형의 알림을 유발하는지와 관련해 우선순위를 더 잘 지정해야 한다.

#### 알림 피로

- 알림이 너무 많으면 심각한 문제가 발생할 수 있다.
- 알림에 압도돼 어떤 조치를 취해야 하는지 판단할 수 없게 될 수도 있다.

#### 더 나은 알림을 위해

- 좋은 알람을 만드는 데 매우 유용한 것들
    - `관련성 relevant`: 경고할 가치가 있는지
    - `고유성 unique`: 경고가 다른 경고를 복제하지 않도록 하라.
    - `적시성 timely`: 알림을 활용할 수 있도록 신속하게 알림을 받아야 한다.
    - `우선순위 prioritized`: 처리할 순서를 정할 수 있도록 하라.
    - `알기 쉬움 understandable`: 명확하고 읽기 쉬움.
    - `진단 diagnostic`: 무엇이 잘못됐는지 명확
    - `자문 advisory`: 운영자가 취해야 할 조치를 이해하도록 도와야 한다.
    - `집중 focusing`: 가장 중요한 문제에 주목하라.

### 6-6. 시맨틱 모니터링

- 시맨틱. 의미론.
- '시스템이 기대하는 대로 동작하고 있는가?' 라는 한 가지 질문을 끊임없이 해야 한다.
    - 시스템이 올바르게 동작한다면 이는 우리가 보고 있는 오류의 우선순위를 정하는 방법을 이해하는 데 도움이 된다.
- 다음으로 해결해야 할 것은 '올바르게 동작하는 시스템에 대한 모델을 어떻게 정의하는가?'다.

#### 실사용자 모니터링

- 운영 시스템에서 실제로 발생하는 상황을 살펴보고 시맨틱 모델과 비교.
- 실제 사용자 모니터링의 문제는 필요한 정보를 적시에 사용하지 못하는 경우가 많다는 것이다.
    - 또한 기본적으로 노이즈가 많다.

### 6-7. 운영 환경에서 테스팅

> 운영 환경에서 테스트하지 않는 것은 마치 집에서 독주 연습이 잘됐다고 전체 오케스트라와 함께 연습하지 않는 것과 같다.
> - 채러티 메이저스

- 운영 환경에서 모든 형태의 테스트는 틀림없이 '모니터링' 활동의 한 형태다.

#### 합성 트랜잭션

- 합성 트랜잭션을 통해 가짜 사용자 행동을 운영 환경 시스템에 주입.
    - 정해진 입력과 예상 출력 포함.

#### A/B 테스트

- 동일한 기능의 두 가지 다른 버전을 배포해 사용자에게는 'A' 또는 'B' 기능 중 하나를 노출.
    - 어떤 버전의 기능이 더 잘 수행되는지 확인 가능

#### 카나리아 릴리스

- 사용자 중 일부만 새 기능의 릴리스를 볼 수 있다.

#### 병렬 실행

- 동일한 기능의 두 가지 동등한 구현을 나란히 실행한다.

#### 스모크 테스트

#### 카오스 엔지니어링

- 카오스 엔지니어링은 운영 시스템에 결함을 주입해 예상되는 문제를 처리한다고 보장할 수 있다.

<br/>

## 7. 표준화

- 지속적으로 균형을 유지해야 하는 활동 중 하나는 아래와 같음.
    - 단일 마이크로서비스에 대해 좁게 의사결정을 내릴 수 있는 부분 vs 시스템 전체에서 표준화해야 하는 부분
- 로그는 표준 형식으로 기록해야.
- 메트릭에 대한 표준 이름 목록도 필요.
- 도구가 도움이 될 수 있다.

<br/>

## 8. 도구 선택

### 8-1. 민주적 선택

- 사용자의 요구를 고려해 도구를 선택하라.

### 8-2. 쉬운 통합

- 시스템에서 올바른 정보를 얻는 것이 필수적.
- 이전보다 더 많은 정보를 다양한 포맷으로 추출해야 할 수도 있다.

### 8-3. 맥락 제공

#### 시간적 맥락

- 1분, 1시간, 1일 또는 1개월 전과 비교해 어떻게 보이는가?

#### 상대적 맥락

- 시스템의 다른 것과 관련해 어떻게 변경됐는가?

#### 관계적 맥락

- 이것에 의존하는 것이 있는가? 혹은 이것이 다른 것에 의존하는가?

#### 비례적 맥락

- 얼마나 나쁜가? 범위가 크거나 작은가? 어떤 것이 영향을 받는가?

### 8-4. 실시간

- 정보를 오래 기다릴 수는 없다.
- 충분히 신속해야 함.

### 8-5. 규모에 맞게

- 규모에 따라 확장할 수 있는 도구가 이상적이며, 여기서도 비용 효율성은 중요하게 작용한다.


<br/>

## 9. 기계화된 전문가

- 행동 변화를 지원하려면 결국 도구가 필요하다. 하지만 신중하게 선택해야 함.
- 전문 지식을 자동화하는 이유?
    - 전문 운영자는 시스템을 운영하는 데 투자할 필요가 없다.
- 자동 이상 감지와 같은 기능이 계속해서 개선될 것이라고 확신하지만, 현재 시스템의 전문가는 인간이며 앞으로도 당분간은 인간일 것임을 인식해야 한다.
- 새로운 멋진 도구가 모든 문제를 해결해줄 것이라는 안이한 생각에 기대서도 안 된다.

<br/>

## 10. 시작하기

- 마이크로서비스가 실행 중인 호스트에 대한 정보(CPU 비율, I/O 등) 캡처.
- 마이크로서비스 인스턴스의 서비스 인터페이스 응답 시간 캡처. 모든 다운 스트림 호출을 로그에 기록.
- 처음부터 로그에 상관관계 ID를 넣고, 비즈니스 포르세스의 다른 주요 단계를 기록.
- 이렇게 하려면 최소한 기본적인 메트릭 및 로그 집계 툴체인이 있어야 한다.

<br/>

# 참고 자료

- 마이크로서비스 아키텍처 구축, 샘 뉴먼 지음
